\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}
\usepackage{tikz}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{listings}
\usetikzlibrary{trees}
\author{R\'emy Detobel \& Nathan Liccardo}
\title{Report Project 2~: XSLT}

\usepackage{color}
\definecolor{Maroon}{rgb}{0.5,0,0}

\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily\footnotesize,
  morestring=[b]",
  moredelim=[s][\bfseries\color{Maroon}]{<}{\ },
  moredelim=[s][\bfseries\color{Maroon}]{</}{>},
  moredelim=[l][\bfseries\color{Maroon}]{/>},
  moredelim=[l][\bfseries\color{Maroon}]{>},
  morecomment=[s]{<?}{?>},
  morecomment=[s]{<!--}{-->},
  commentstyle=\color{DarkOliveGreen},
  stringstyle=\color{blue},
  identifierstyle=\color{red}
}

\renewcommand\thesection{\arabic{section}}

\begin{document}
\maketitle

\section{Introduction}
This document aims to detail all the choices that we made during our implementation. As a reminder, the main goal of this project was to create an xslt file. This file had to be able to transform a part of the dblp database into html files. Our xslt file has been separated into two parts : functions and template. This report will follow the same structure.

\section{Functions}
There exist five complex operations which have necessitated to create functions. This first section will be focused on describing those functions (\verb|removeSpecialChar|, \verb|lastName|, \verb|firstName|, \verb|firstLetter| and \verb|nameToPath|).

\paragraph{Remove Special Char} Is used to replace all the non-alphanumeric characters. It takes (as input) a person name (like "C. B. Williams") and replace each characters which matches with the following regex~: \verb|[^0-9a-zA-Z_]|. Matching characters are replaced by the equal character (=). Substitute a specific characters can be realised thanks to the \verb|replace(input, regex, char)| function. This function is defined in xslt 2.0.

\paragraph{Last Name} Can extract the string corresponding to the last name. To be able to extract and format this element from the given input, we used two functions : 
\begin{enumerate}
\item \verb|tokenize| : Split the input into an array (using white spaces). Last name is corresponding to the last element. This function is defined in xslt 2.0.
\item \verb|removeSpecialChar| : Replace (eventual) special characters from the last name. The exact definition has been given previously.
\end{enumerate}

\paragraph{First Name} Can extract the first name from the given input string. Formally, first name is corresponding to all the input string minus the last name (defined before). To extract and format this element as requested, we used four functions :
\begin{enumerate}
\item \verb|tokenize| : Split the input string (using white spaces) and get the last name (last element).
\item \verb|substring-before| : Get all the string before the last name.
\item \verb|replace| : Replace each white spaces by equal characters in the sub-string result.
\item \verb|removeSpecialChar| : Used as defined before on the replace result.
\end{enumerate}

\paragraph{First Letter} Is used to extract first letter of the last name. The function use \verb|substring| to select the first letter (as with substring-before), \verb|tokenize| to split the input string) and \verb|removeSpecialChar| to replace the character (if it is non-alphanumeric). In addition, we use the \verb|lower-case| function defined in xslt 2.0. 

\paragraph{Name To Path} Is used to properly format each html file name. Thanks to each previous functions, we are now able to get the first letter of the last name, the first name and the last name. Each of those strings will be concatenated as follow : 
\begin{verbatim}
    "firstLetter"/"lastName":"firstName"
\end{verbatim}
Where "firstLetter", "lastName" and "firstName" are the output strings given by each previous functions.

\section{Template}
Templates are used to define set of rules. Our project only use one template. This element will, in fact, contain each rules corresponding to the transformation from XML to HTML files. This sections will focus on two main elements : Xpath and HTML file structure. Xpath is used to describe path in XML. To correctly understand the structure of the template, we will describe each elements in sequence.

\subsection{Creation of HTML pages} 
Each author or editor must have an HTML page. This means that we must iterate on the dblp database and get each different authors or editors. To do this, we used the \verb|for-each| tag. This tag use an Xpath which is defined as follow : 
\begin{verbatim}
    select="distinct-values(//author|//editor)"
\end{verbatim}
For each element (author or editor) contained in this set we create an HTML file. Those file are created using the \verb|result-document| tag as follow :
\begin{verbatim}
    <xsl:result-document href="{func:nameToPath(.)}.html">
\end{verbatim}
We can see that we use the \verb|nameToPath| function previously defined. The string given as parameter is corresponding to the current element in the set of authors and editors. For each pages, we generate different body that we will describe in the next section.

\subsection{Title and articles table}
For each page, we must have the author name as title followed by a table which contain each articles of the author. Regarding to the title, this is realised as below : 
\begin{verbatim}
    <h1> <xsl:value-of select="."/> </h1>
\end{verbatim}
We must now create a table which contain each article corresponding to the current author. This means that we must~:
\begin{itemize}
\item Obtain each publications. This is realised using a variable declared after the body tag. This variable contains each articles which contains the current author.
\item Order each publications in the descending order. This is realised using the \verb|sort| tag with the \verb|descending| parameter. Both are defined in xslt 2.0.
\item Create a subsection for each year. This is realised by using a \verb|test| tag and the following condition~: \verb|not(preceding-sibling::*[1]/year=./year) or position()=1|. Indeed, this condition checks if the previous item as the same value for the node \verb|year|.
\item Add the publication number. As we must count publications in the reverse order, we use a variable (\verb|indexPub|, declared after the \verb|sort|). Index value is obtained by : \verb|last()-position()+1|.
\item Add, each authors or editors of the current publication and link all of them to their personal web page. This is also realised using the \verb|nameToPath| function.
\end{itemize}

\subsection{Co-author index}
Finally, for each HTML page, we must have a table which contain all other persons with whom P has jointly published. To realise this, we use two iterations :
\begin{itemize}
\item On each authors which have jointly published with the current author. This is realised using an \verb|for-each| tag and the following request :
\begin{verbatim}
    select="$root//*[./author=$author]/author[not(.=$author)]"
\end{verbatim}
\item If we call the author of this new iteration A2 and the initial author A1, we iterate on all the publication of A1 and check if A2 is also an author. If it is the case, then we can add the publication~:
\begin{verbatim}
    <xsl:for-each select="$publications">
        <xsl:if test="$coAuthor=./author" >
            <xsl:variable name="linkPublication" select="last()-position()+1" />
             [<a href="#p{$linkPublication}">
              <xsl:value-of select="$linkPublication" />
              </a>]
        </xsl:if>
    </xsl:for-each>
\end{verbatim}
\end{itemize}
\end{document}



