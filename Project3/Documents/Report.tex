\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}
\usepackage{tikz}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{listings}
\usetikzlibrary{trees}
\author{R\'emy Detobel \& Nathan Liccardo}
\title{Report Project 3~: XQuery}

\usepackage{color}
\definecolor{Maroon}{rgb}{0.5,0,0}

\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily\footnotesize,
  morestring=[b]",
  moredelim=[s][\bfseries\color{Maroon}]{<}{\ },
  moredelim=[s][\bfseries\color{Maroon}]{</}{>},
  moredelim=[l][\bfseries\color{Maroon}]{/>},
  moredelim=[l][\bfseries\color{Maroon}]{>},
  morecomment=[s]{<?}{?>},
  morecomment=[s]{<!--}{-->},
  commentstyle=\color{DarkOliveGreen},
  stringstyle=\color{blue},
  identifierstyle=\color{red},
  showstringspaces=false
}

\renewcommand\thesection{\arabic{section}}

\begin{document}
\maketitle

\section{Introduction}
  This document aims to detail each choices and hypothesis we made during our implementation. As a reminder, we were assigned to implement three different XQuery programs. Each of those query use a part of the BDLP database (DBLP-excerpt). The structure of this report will be divided into three parts (one per program).

\section{First XQuery program}
  For the first program, we were assigned (for each author) to return the number of co-authors and the number of joint publications with each of them. To realise this, we start by iterate on each author as below~: 
  \begin{itemize}
    \item \begin{verbatim}
for $author in //author
    return <author>
        ....
    </author>\end{verbatim}
  \end{itemize}
  Which will create an \verb|<author> ... </author>| bloc for each author. Inside each of these blocs, we will find following informations (in sequence).
  
  \subsection{Author name and Co-authors informations}
    The author name and the number of co-authors are respectively obtained using \verb|data| and \verb|count| functions (defined by XQuery). Below instructions are formal definitions of \verb|name| and \verb|coauthors| tags~:
    \begin{itemize}
      \item \verb|<name>{data($author)}</name>|
      \item \verb|<coauthors number="{count(//*[author=$author]/author)-1}"> ... </coauthors>|
    \end{itemize}
    
    \subsubsection{Co-authors informations}
      For each co-author, we must obtain his name and the number of joint publications. Both informations will be contained inside \verb|<coauthor> ... </coauthor>| tags (itself contained in the \verb|coauthors| bloc). Each of the \verb|coauthor| blocs are created by iterating on co-authors as below~:
      \begin{itemize}
	\item \begin{verbatim}
for $coauthor in //*[author=$author]/author[not(.=$author)]
    return <coauthor>
    ....
    </coauthor>\end{verbatim}
      \end{itemize}
      
      \paragraph{Co-author name}
	As for the author name, co-author name is reached using the \verb|data| function on the \verb|coauthor| variable. This is realised as follow~:
	\begin{itemize}
	  \item \verb|<name>{data($coauthor)}</name>|
	\end{itemize}
	
      \paragraph{Joint publications}
	For each co-author, we must retrieve the number of joint publications. Once again, this is achieved using the \verb|count| function available in XQuery. Here is the final instruction~:
	\begin{itemize}
	  \item \verb|<nb_joint_pubs>{count(//*[author=$author]/author[.=$coauthor])}</nb_joint_pubs>|
	\end{itemize}


\section{Second XQuery program}
  For the second request, we were assigned to give (for each proceedings) its title and titles of articles appearing in it. Each \verb|proceeding| blocs are created by the use of an iteration~:
  \begin{itemize}
    \item \begin{verbatim}
for $proceeding in //proceedings
    return <proceedings>
    ....
    </proceedings>\end{verbatim}
  \end{itemize}
  For each of these blocs, we must retrieve the title (\verb|proc_title|) and a list of articles (\verb|title|). This is achieved using the value of the \verb|key| attribute (inside \verb|proceedings| tags) and the value contained inside \verb|crossref| tags. Regarding to the title, we obtain the below instruction~:
  \begin{itemize}
    \item \verb|<proc_title>{data($proceeding/title)}</proc_title>|
  \end{itemize}
  Finally, we can create the list of titles using the \verb|key| value~:  
  \begin{itemize}
    \item \begin{verbatim}
for $inproceeding in //inproceedings[crossref=data($proceeding/@key)]
return <title>{data($inproceeding/title)}</title>\end{verbatim}
  \end{itemize}
  

\section{Third XQuery program}
  For the last program, we were assigned to compute (for each pair of authors $x$ and $y$, $x \neq y$) the distance between $x$ and $y$. Before explaining the final request, we will describe how we use functions to implement complex operations. We have implement a function which return all co-author within a defined distance (named \verb|getListAuthorDistance|). Then, all authors at a distance $d$ are iteratively recovered, excluding all authors at a distance $d-1$. We stop the iteration when all authors accessible at a distance $d$, are also accessible at a distance $d-1$, i.e. when no new author is accessible.
  
  \subsection{First function : \texttt{getListAuthorDistance}}
    This recursive function begin to check if the distance is strictly greeter than zero.  If it is the case, for all author who have an interaction with the intermediare author (passed as parameter (the first intermediate and the author himself)) we re-call the function (and return the current intermediare author).\\
    If distance is equals to zero, we just return the intermediare author (passed as parameter).
  
    Concretely in XML the iteration loop is written as follows~:
    \begin{itemize}
      \item \begin{verbatim}
for $newCoAuteur in distinct-values($allContext[author=$intermediateAuteur]/author)
where not($intermediateAuteur = $newCoAuteur)
  return ($newCoAuteur, 
      custom:getListAuthorDistance($allContext, ($distance - 1), $newCoAuteur))\end{verbatim}
    \end{itemize}
    
  \subsection{Other functions}
    
  
  \subsection{Final instruction}
    Finally, we must create the \verb|<distance> .... </distance>| bloc which contain each of the \verb|<distance>| tags. Those tags are created using the first function and added to the final set using the second one. First call to of the recursive function is realised for each different authors in the dblp database. This means that we use the following code inside the \verb|<distance> .... </distance>| bloc~:
    \begin{itemize}
      \item \begin{verbatim}
for $author in distinct-values(//author)
    return custom:loopDistance($author, $author, 0, //*)\end{verbatim}
    \end{itemize}
    Which is used to initialise each of the \verb|getTree| parameters. Remarks also that distance is set to 0 due to the fact that we start by using the same author and co-author (not added to the final set).

\end{document}

